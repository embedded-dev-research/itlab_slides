\documentclass{beamer}

% Theme choice
\usetheme{Madrid}

% Optional packages
\usepackage{graphicx} % For including images
\usepackage{amsmath}  % For math symbols and formulas
\usepackage{hyperref} % For hyperlinks

\title[Git intro]{Git intro}
\author{Obolenskiy Arseniy, Nesterov Alexander}
\institute{ITLab}

\date{\today}

% Redefine the footline to display both the short title and the org name
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
    \begin{beamercolorbox}[wd=.45\paperwidth,ht=2.5ex,dp=1ex,leftskip=1em,center]{author in head/foot}%
        \usebeamerfont{author in head/foot}\insertshortinstitute% Displays the university name
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.45\paperwidth,ht=2.5ex,dp=1ex,leftskip=1em,center]{author in head/foot}%
      \usebeamerfont{author in head/foot}\insertshorttitle% Displays the short title
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.1\paperwidth,ht=2.5ex,dp=1ex,rightskip=1em,center]{author in head/foot}%
      \usebeamerfont{author in head/foot}\insertframenumber{} / \inserttotalframenumber%
    \end{beamercolorbox}}%
  \vskip0pt%
}

\AtBeginSection[]{
  \begin{frame}
    \centering
    \Huge\insertsection%
  \end{frame}
}

\begin{document}

\begin{frame}
    \titlepage%
\end{frame}

\begin{frame}{Contents}
    \tableofcontents
\end{frame}

\section{What are version control systems?}

\begin{frame}{Version control systems}
  \textbf{A version control system (VCS)} is a software tool that helps individuals and teams manage changes to source code, documents, and other collections of information over time.
  \begin{itemize}
    \item It is a persistent data structure (data structure that maintains its previous versions after modifications, allowing access to both current and past versions of the data)
    \item This is in contrast to ephemeral data structures, where changes overwrite the current state, losing prior versions
  \end{itemize}
\end{frame}

\section{What version control systems exist? History and evolution}

\begin{frame}{Early Days of Computing (1950s--1970s). SCCS}
  Before the development of dedicated version control systems, programmers used manual processes to manage changes. Early systems, like the Source Code Control System (SCCS), developed by Marc Rochkind at Bell Labs in 1972, were among the first tools created to automate version control. SCCS stored multiple versions of code and helped manage modifications through change sets, allowing programmers to revert to earlier versions if necessary.
  \begin{block}{SCCS subcommands}
    admin -i file.f s.file.f --- Put subs under SCCS control.\\
    get s.file.f --- Retrieve, read only.\\
    get -e s.file.f --- Retrieve, read/write (e = edit).\\
    get -p s.file.f --- Retrieve, just peak.\\
    delta s.file.f --- Store changes.\\
    prs s.file.f --- List revisions.\\
  \end{block}

  \footnotesize Source: \href{https://sites.science.oregonstate.edu/~landaur/nacphy/coping-with-unix/node169.html}{https://sites.science.oregonstate.edu/~landaur/nacphy/coping-with-unix/node169.html}
\end{frame}

\begin{frame}{Centralized Version Control Systems (1980s--1990s)}
  Centralized version control systems (CVCS) came to prominence during the 1980s. These systems required a single, central server where all files and version histories were stored. Developers had to be connected to this server to commit changes or retrieve updates.
  \begin{itemize}
    \item RCS (Revision Control System): Developed by Walter Tichy in the early 1980s, RCS is a more advanced system than SCCS.\@ It introduced features like automated version numbering and handling of concurrent edits, but it was still a single-user system.
    \item CVS (Concurrent Versions System): Introduced in 1990, CVS extended RCS with support for multiple developers working on the same project. It allowed distributed teams to collaborate more effectively, although merging changes was often difficult.
    \item SVN (Subversion): developed as an improvement over older systems like CVS.\@ It was created by CollabNet in 2000 and later became an Apache project.
  \end{itemize}
\end{frame}

\begin{frame}{Distributed Version Control Systems (2000s)}
  The limitations of centralized systems (reliance on a single server), led to the development of distributed version control systems (DVCS) in the early 2000s. In DVCS, every developer has a complete copy of the project, including its entire history, on their local machine.
  \begin{itemize}
    \item BitKeeper (1998): BitKeeper was one of the first DVCS, created by Larry McVoy. It gained fame for being used by the Linux kernel project until a licensing dispute in 2005 led to its discontinuation in favor of free alternatives.
    \item Git (2005): Linus Torvalds, creator of Linux, developed Git after the fallout with BitKeeper. Git was designed with performance, flexibility, and speed in mind, especially for large projects like the Linux kernel. Git introduced powerful features such as branching, merging, and decentralized collaboration.
    \item Mercurial (2005): Developed around the same time as Git, Mercurial is another DVCS designed for speed and scalability. While it shares many similarities with Git, it is known for being more user-friendly and consistent in behavior.
  \end{itemize}
\end{frame}

\section{What is Git?}

\begin{frame}{What is Git?}
  \begin{itemize}
    \item Git is a distributed version control system (DVCS) for tracking changes in source code during software development.
    \item Created by Linus Torvalds in 2005.
    \item Allows multiple developers to efficiently work on the same project and creates and environment for effective collaboration on software project.
    \item Key features:
    \begin{itemize}
        \item Distributed architecture
        \item Free and open source
        \item Wide usage in the industry
        \item Speed and efficiency
        \item Data integrity
        \item Support for non-linear development (parallel work on different features)
        \item History and blame tracking
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Basic Git commands}

\begin{frame}{Key concepts}
  \begin{itemize}
    \item Version control system
    \item Repository
    \item Commit
    \item Branch
  \end{itemize}
\end{frame}

\begin{frame}{Download Git}
  \begin{enumerate}
      \item Navigate to the official Git website: \url{https://git-scm.com/}
      \item Click on the \textbf{Downloads} section.
      \item Select the appropriate version for your operating system (Windows, macOS, Linux).
      \item Follow the installation instructions provided.
  \end{enumerate}
\end{frame}

\begin{frame}{Creating a New Repository}
  \begin{itemize}
    \item Initialize a new Git repository in an existing directory:
    \begin{block}{Command}
        \texttt{git init}
    \end{block}
    \item Clone an existing repository:
    \begin{block}{Command}
        \texttt{git clone <repository-url>}
    \end{block}
      This could be the repository hosted anywhere (GitHub, GitLab or other platforms) or local repository
  \end{itemize}
\end{frame}

\begin{frame}{Commit}
  In Git, a commit is a fundamental unit of change.
  Commit has a unique identifier (commit hash) and it holds a number of options:
  \begin{itemize}
    \item Hash: unique identifier (SHA-1 checksum).
        This allows Git to uniquely identify each commit in the history of the project.
    \item Message: description (what was done in this change)
    \item Author (name, e-mail)
  \end{itemize}
\end{frame}

\begin{frame}{Commit message}
  Generally consists of two parts:
  \begin{itemize}
    \item Subject line (summary)
      \begin{itemize}
        \item Usually is short (up to 50 characters)
        \item Imperative is used (e.g., ``Fix bug in user login'' or ``Add tests for API endpoint'').
        \item Avoid periods at the end of the line
      \end{itemize}
    \item Body (optional)
      \begin{itemize}
        \item Wrap lines at 72 characters
        \item Explain why the change was made, rather than just what was done (the code diff itself explains the ``what'').
      \end{itemize}
  \end{itemize}
  \begin{block}{Commit message example}
    Add caching for user profile data\vspace{1em}

    This improves the performance of loading user profiles by
    caching the data in memory. Previously, each request would
    query the database, which caused a significant slowdown.
  \end{block}
\end{frame}

\begin{frame}{Commit best practices}
  \begin{itemize}
    \item Write meaningful commit messages: Follow the rules from previous slide. This helps others (and future you) understand the purpose of each commit.
    \item Make small, logical commits: Each commit should represent a single logical change. Avoid lumping multiple unrelated changes into one commit.
      \begin{itemize}
        \item If you can split your commit into two in many cases it is better to do this.
        \item If your commit message contains the word ``and'' this might be a signal that commit can be split
      \end{itemize}
    \item Write meaningful commit messages: This helps others (and future you) understand the purpose of each commit.
    \item Commit often: Regular commits allow you to track progress and makes it easier to revert to a stable state if something goes wrong.
  \end{itemize}
\end{frame}

\begin{frame}{Commit importance}
  \begin{figure}[h]
    \centering
    \includegraphics[width=0.75\textwidth]{images/in-case-of-fire.png}
  \end{figure}
  {\footnotesize Source: \href{https://github.com/hendrixroa/in-case-of-fire}{https://github.com/hendrixroa/in-case-of-fire}}
\end{frame}

\begin{frame}{First Commit}
  \begin{itemize}
      \item Check the status of your repository:
      \begin{block}{Command}
        \texttt{git status}
      \end{block}
      \item Stage files for commit:\\
        Before you make a commit, changes must be added to the \textbf{staging area} using \texttt{git add}. This allows you to carefully select which changes to include in a commit. For example, you might only want to commit changes to one file, even if you've modified several others.
      \begin{block}{Command}
        \texttt{git add <file>}
      \end{block}
      \item Commit changes:
      \begin{block}{Command}
          \texttt{git commit -m ``Commit message''}
      \end{block}
  \end{itemize}
\end{frame}

\begin{frame}{Conventional Commits}
  There are multiple examples of organizing commit messages naming (so called convention)

  \footnotesize
  A lightweight convention for commit messages that enables readable history and automation. See \href{https://www.conventionalcommits.org/}{conventionalcommits.org}
  \begin{itemize}
    \item Format: \texttt{type (scope)!: subject}
    \item Common types: \texttt{feat}, \texttt{fix}, \texttt{docs}, \texttt{style},
      \texttt{refactor}, \texttt{test}, \texttt{chore}, \texttt{perf}, \texttt{build}, \texttt{ci}
    \item \textbf{scope} is optional; \textbf{subject} is imperative, no period
    \item Benefits: clear intent, auto changelogs, easier reviews, semantic versioning triggers
  \end{itemize}
\end{frame}

\begin{frame}{Conventional Commits: Examples}
  \begin{block}{Examples}
    \texttt{feat (auth): add OAuth2 login}\newline
    \texttt{fix (api): handle 404 on users endpoint}\newline
    \texttt{docs (readme): clarify local setup steps}\newline
    \texttt{refactor (core)!: remove legacy sync path}\newline
    \texttt{BREAKING CHANGE\@: sync\@() removed; use syncAsync\@()}\newline
    \texttt{test (router): add coverage for redirects}
  \end{block}
  \vspace{0.4em}
  Tips: keep scope small; group commits by intent; reference issues when helpful (e.g., \texttt{fix: handle null refs (closes \#123)}).
\end{frame}

\begin{frame}{Branches in Git}
  \footnotesize
  In Git, a branch represents an independent line of development, enabling you to work on different features, fixes, or experiments without affecting the main line of the project.\\
  \textbf{A branch} is a movable pointer to a commit. It allows users to develop different project directions in parallel.\\
  e.g.\ several developers are working on several different independant features
  \begin{itemize}
      \item Create a new branch:
      \begin{block}{Command}
        \texttt{git branch <branch-name>}
      \end{block}
      \item Switch to a branch:
      \begin{block}{Command}
        \texttt{git checkout <branch-name>}
      \end{block}
      \item Create and switch to a new branch:
      \begin{block}{Command}
        \texttt{git checkout -b <branch-name>}
      \end{block}
  \end{itemize}
\end{frame}

\begin{frame}{Viewing Commit History}
  \begin{itemize}
    \item View the commit history:
    \begin{block}{Command}
      \texttt{git log}
    \end{block}
    \item View a summarized commit history (one line per commit):
    \begin{block}{Command}
      \texttt{git log --oneline}
    \end{block}
    \item View graphical representation of branches:
    \begin{block}{Command}
      \texttt{git log --graph --oneline --all}
    \end{block}
  \end{itemize}
\end{frame}

\section{Advanced Git Operations}

\begin{frame}{Advanced Git Commands}
  \textbf{Stashing Changes}:
  \begin{itemize}
    \item Save work in progress without committing:
    \begin{block}{Commands}
      \texttt{git stash} --- Save current changes\newline
      \texttt{git stash pop} --- Apply and remove latest stash\newline
      \texttt{git stash list} --- View all stashes
    \end{block}
  \end{itemize}
  
  \textbf{Rebasing}:
  \begin{itemize}
    \item Rewrite commit history for cleaner timeline:
    \begin{block}{Commands}
      \texttt{git rebase main} --- Replay commits on top of main\newline
      \texttt{git rebase -i HEAD~3} --- Interactive rebase last 3 commits
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}{Updating Feature Branch: Why}
  \footnotesize
  Keeping your feature branch current with \texttt{main} helps to:
  \begin{itemize}
    \item Reduce integration pain and surface conflicts early
    \item Ensure CI runs against the latest base code
    \item Keep PRs small, focused, and easy to review
    \item Avoid long-lived drift that complicates release
  \end{itemize}
\end{frame}

\begin{frame}{Update via Merge}
  \footnotesize
  Preserve history by merging the latest \texttt{main} into your feature.
  \begin{block}{Commands}
    \texttt{git fetch origin}\newline
    \texttt{git checkout <feature>}\newline
    \texttt{git merge origin/main}
  \end{block}
  \begin{itemize}
    \item Pros: no history rewrite; safe for shared branches
    \item Cons: adds merge commits; history may be noisier
  \end{itemize}
\end{frame}

\begin{frame}{Update via Rebase}
  \footnotesize
  Create a linear history by replaying your work on top of \texttt{main}.
  \begin{block}{Commands}
    \texttt{git fetch origin}\newline
    \texttt{git checkout <feature>}\newline
    \texttt{git rebase origin/main}
  \end{block}
  If conflicts: fix files, \texttt{git add <file>}, then \texttt{git rebase --continue}. To cancel: \texttt{git rebase --abort}.
  \begin{itemize}
    \item Pros: cleaner, linear history; easier to review
    \item Cons: rewrites commits; avoid on shared/public branches
  \end{itemize}
\end{frame}

\begin{frame}{Cherry-pick a Commit}
  \footnotesize
  Apply (pick) an existing commit onto your current branch without merging entire branches.
  \begin{itemize}
    \item Common uses: bring a specific fix, backport a change.
    \item Usage:
    \begin{block}{Commands}
      \texttt{git cherry-pick <commit>} --- Apply a single commit\newline
      \texttt{git cherry-pick A..B} --- Apply a range (excludes A, up to B)\newline
      \texttt{git cherry-pick <c1> <c2>} --- Apply multiple commits
    \end{block}
    \item Useful flags:
    \begin{block}{Flags}
      \texttt{-x} --- Append ``cherry picked from commit hash (SHA)'' to the message\newline
      \texttt{-n} (\texttt{--no-commit}) --- Do not create a commit; leave changes staged
    \end{block}
  \end{itemize}
  It is called ``cherry-picking'' because you are selecting (or ``picking'') specific commits from one branch to apply to another, much like picking cherries from a tree.
\end{frame}

\begin{frame}{Handling Merge Conflicts}
  \textbf{When Conflicts Occur}:
  \begin{itemize}
    \item Same file modified in different branches
    \item Automatic merge fails, manual resolution required
  \end{itemize}
  
  \textbf{Resolution Process}:
  \begin{enumerate}
    \item Identify conflicted files: \texttt{git status}
    \item Open files and look for conflict markers:
    \begin{block}{Conflict Markers}
      \texttt{<<<<<<< HEAD}\newline
      \texttt{Your changes}\newline
      \texttt{=======}\newline
      \texttt{Incoming changes}\newline
      \texttt{>>>>>>> branch-name}
    \end{block}
    \item Edit files to resolve conflicts
    \item Stage resolved files: \texttt{git add <file>}
    \item Complete merge: \texttt{git commit}
  \end{enumerate}
\end{frame}

\section{Git workflows overview}

\begin{frame}{Push to Master (Linear history approach)}
  \begin{itemize}
      \item All changes are made directly to the \texttt{master} branch.
      \item Simplest workflow, suitable for small projects.
      \item Potential issues:
      \begin{itemize}
          \item Conflicts when multiple developers push simultaneously.
          \item No isolation for new features or bug fixes.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Using Feature Branches}
  \begin{itemize}
      \item Create separate branches for new features or bug fixes.
      \item Benefits:
      \begin{itemize}
          \item Isolates development work.
          \item Facilitates code reviews.
          \item Safe integration into \texttt{master} after testing.
      \end{itemize}
      \item Workflow:
      \begin{enumerate}
          \item Create a new branch: \texttt{git checkout -b <feature-branch>}
          \item Develop and commit changes on the feature branch.
          \item Merge back into \texttt{master} when ready.
      \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}{Trunk-based development}
  \begin{itemize}
    \item Developers commit directly to the \texttt{trunk} (main branch), avoiding long-lived branches
    \item Encourages continuous integration by integrating small changes frequently
    \item If branches are used, they are short-lived (usually less than a day) and merged back quickly
    \item Use of feature flags is encouraged and allows incomplete features to be safely included in the main codebase
    \item Benefits:
    \begin{itemize}
      \item Reduces merge conflicts and integration problems
      \item Simplifies version control management
      \item Facilitates rapid release cycles and continuous deployment
    \end{itemize}
    \item Drawbacks:
    \begin{itemize}
      \item Requires high discipline from developers to commit stable, working code frequently
      \item Feature flags can become complex to manage, especially if there are many incomplete features
      \item Approach is not suitable for big teams and teams working on long-term
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{GitHub Flow}
  \begin{itemize}
      \item Lightweight, branch-based workflow suitable for continuous deployment.
      \item Steps:
      \begin{enumerate}
          \item \textbf{Create a branch} for your work.
          \item \textbf{Commit} changes to your branch.
          \item \textbf{Open a Pull Request} when your work is ready.
          \item \textbf{Discuss and review} your code.
          \item \textbf{Merge} the Pull Request once approved.
          \item \textbf{Deploy} to production.
      \end{enumerate}
      \item Benefits:
      \begin{itemize}
        \item Emphasizes collaboration and code quality.
        \item Organized workflow for medium projects (a team or several teams that consist of several people).
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{GitHub Flow}
  \begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/github-flow.png}
  \end{figure}
  {\footnotesize Source: \href{https://github.com/a-a-ron/Github-Flow}{https://github.com/a-a-ron/Github-Flow}}
\end{frame}

\begin{frame}{Git Flow}
  \begin{itemize}
      \item A robust branching model for managing releases.
      \item Defines specific branches:
      \begin{itemize}
          \item \textbf{master} --- contains production-ready code.
          \item \textbf{develop} --- integration branch for features.
          \item \textbf{feature branches} --- for new features.
          \item \textbf{release branches} --- prepare for a new production release.
          \item \textbf{hotfix branches} --- quick fixes for production.
      \end{itemize}
      \item Benefits:
      \begin{itemize}
          \item Organized workflow for large projects.
          \item Clear separation of different types of work.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Git Flow}
  \begin{figure}[h]
    \centering
    \includegraphics[height=0.87\textheight]{images/git-flow.png}
  \end{figure}
\end{frame}

\begin{frame}
    \centering
    \Huge{Thank You!}
\end{frame}

\begin{frame}{References}
  \begin{enumerate}
    \item Git Download \href{https://git-scm.com/downloads}{https://git-scm.com/downloads}
    \item Git Book \href{https://git-scm.com/book/en/v2}{https://git-scm.com/book/en/v2}
    \item Git Flow Tutorial by Atlassian \href{https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow}{https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow}
    \item Git Flow cheatsheet \href{https://danielkummer.github.io/git-flow-cheatsheet/}{https://danielkummer.github.io/git-flow-cheatsheet/}
    \item GitHub Flow Tutorial by GitHub \href{https://docs.github.com/en/get-started/using-github/github-flow}{https://docs.github.com/en/get-started/using-github/github-flow}
    \item Conventional Commits \href{https://www.conventionalcommits.org/}{https://www.conventionalcommits.org/}
  \end{enumerate}
\end{frame}

\end{document}
